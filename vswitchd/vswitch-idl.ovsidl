//
// This is an ovsdb-idl schema.  The OVSDB IDL compiler, ovsdb-idlc,
// can translate it into an OVSDB schema (which simply entails
// deleting some members from the schema) or C headers or source for
// use with the IDL at runtime.
//

{"name": "ovs_vswitchd_db",
 "comment": "Configuration for one Open vSwitch daemon.",
 "idlPrefix": "ovsrec_",
 "idlHeader": "\"vswitchd/vswitch-idl.h\"",
 "tables": {
   "Open_vSwitch": {
     "comment": "Configuration for an Open vSwitch daemon.",
     "columns": {
       "bridges": {
         "comment": "Set of bridges managed by the daemon.",
         "type": {"key": "uuid", "keyRefTable": "Bridge",
                  "min": 0, "max": "unlimited"}},
       "management_id": {
         "comment": "Exactly 12 hex digits that identify the daemon.",
         "type": "string"},
       "controller": {
         "comment": "Default Controller used by bridges.",
         "type": {"key": "uuid", "keyRefTable": "Controller", "min": 0, "max": 1}},
       "ssl": {
         "comment": "SSL used globally by the daemon.",
         "type": {"key": "uuid", "keyRefTable": "SSL", "min": 0, "max": 1}}}},
   "Bridge": {
     "comment": "Configuration for a bridge within an Open_vSwitch.",
     "columns": {
       "name": {
         "comment": "Bridge identifier.  Should be alphanumeric and no more than about 8 bytes long.  Must be unique among the names of ports, interfaces, and bridges on a host.",
         "type": "string"},
       "datapath_id": {
         "comment": "OpenFlow datapath ID.  Exactly 12 hex digits.",
         "type": {"key": "string", "min": 0, "max": 1}},
       "hwaddr": {
         "comment": "Ethernet address to use for bridge.  Exactly 12 hex digits in the form XX:XX:XX:XX:XX:XX.",
         "type": {"key": "string", "min": 0, "max": 1}},
       "ports": {
         "comment": "Ports included in the bridge.",
         "type": {"key": "uuid", "keyRefTable": "Port", "min": 0, "max": "unlimited"}},
       "mirrors": {
         "comment": "Port mirroring configuration.",
         "type": {"key": "uuid", "keyRefTable": "Mirror", "min": 0, "max": "unlimited"}},
       "netflow": {
         "comment": "NetFlow configuration.",
         "type": {"key": "uuid", "keyRefTable": "NetFlow", "min": 0, "max": 1}},
       "controller": {
         "comment": "OpenFlow controller.  If unset, defaults to that specified by the parent Open_vSwitch.",
         "type": {"key": "uuid", "keyRefTable": "Controller", "min": 0, "max": 1}}}},
   "Port": {
     "comment": "A port within a Bridge.  May contain a single Interface or multiple (bonded) Interfaces.",
     "columns": {
       "name": {
         "comment": "Port name.  Should be alphanumeric and no more than about 8 bytes long.    May be the same as the interface name, for non-bonded ports.  Must otherwise be unique among the names of ports, interfaces, and bridges on a host.",
         "type": "string"},
       "interfaces": {
         "comment": "The Port's Interfaces.  If there is more than one, this is a bonded Port.",
         "type": {"key": "uuid", "keyRefTable": "Interface", "min": 1, "max": "unlimited"}},
       "trunks": {
         "comment": "The 802.1Q VLAN(s) that this port trunks.  Should be empty if this port trunks all VLAN(s) or if this is not a trunk port.",
         "type": {"key": "integer", "min": 0, "max": 4096}},
       "tag": {
         "comment": "This port's implicitly tagged VLAN.  Should be empty if this is a trunk port.",
         "type": {"key": "integer", "min": 0, "max": 1}},
       "mac": {
         "comment": "The MAC address to use for this port for the purpose of choosing the bridge's MAC address.  This column does not necessarily reflect the port's actual MAC address, nor will setting it change the port's actual MAC address.  Exactly 12 hex digits in the form XX:XX:XX:XX:XX:XX.",
         "type": {"key": "string", "min": 0, "max": 1}},
       "bond_updelay": {
         "comment": "For a bonded port, the number of milliseconds for which carrier must stay up on an interface before the interface is considered to be up.  Ignored for non-bonded ports.",
         "type": "integer"},
       "bond_downdelay": {
         "comment": "For a bonded port, the number of milliseconds for which carrier must stay down on an interface before the interface is considered to be down.  Ignored for non-bonded ports.",
         "type": "integer"},
       "bond_fake_iface": {
         "comment": "For a bonded port, whether to create a fake interface with the name of the port.  Use only for compatibility with legacy software that requires this.",
         "type": "boolean"}}},
   "Interface": {
     "comment": "An interface within a Port.",
     "columns": {
       "name": {
         "comment": "Interface name.  Should be alphanumeric and no more than about 8 bytes long.  May be the same as the port name, for non-bonded ports.  Must otherwise be unique among the names of ports, interfaces, and bridges on a host.",
         "type": "string"},
       "type": {
         "comment": "The interface type.  Normal network devices, e.g. eth0, have type \"system\" or \"\" (which are synonyms).  Internal ports have type \"internal\".  TUN/TAP devices have type \"tap\".",
         "type": "string"},
       "options": {
         "comment": "Configuration options whose interpretation varies based on \"type\".",
         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"}},
       "internal": {
         "comment": "An \"internal\" port is one that is implemented in software as a logical device.",
         "type": "boolean"},
       "ingress_policing_rate": {
         "comment": "Maximum rate for data received on this interface, in kbps.  Set to 0 to disable policing.",
         "type": "integer"},
       "ingress_policing_burst": {
         "comment": "Maximum burst size for data received on this interface, in kb.  The default burst size if set to 0 is 10 kb.",
         "type": "integer"},
       "mac": {
         "comment": "Ethernet address to set for this interface.  If unset then the default MAC address is used.  May not be supported on all interfaces.  Exactly 12 hex digits in the form XX:XX:XX:XX:XX:XX.",
         "type": {"key": "string", "min": 0, "max": 1}}}},
   "Mirror": {
     "comment": "A port mirror within a Bridge.",
     "columns": {
       "name": {
         "comment": "Arbitrary identifier for the Mirror.",
         "type": "string"},
       "select_src_port": {
         "comment": "Ports on which arriving packets are selected for mirroring.",
         "type": {"key": "uuid", "keyRefTable": "Port", "min": 0, "max": "unlimited"}},
       "select_dst_port": {
         "comment": "Ports on which departing packets are selected for mirroring.",
         "type": {"key": "uuid", "keyRefTable": "Port", "min": 0, "max": "unlimited"}},
       "select_vlan": {
         "comment": "VLANs on which packets are selected for mirroring.",
         "type": {"key": "integer", "min": 0, "max": 4096}},
       "output_port": {
         "comment": "Output port for selected packets.  Mutually exclusive with output_vlan.",
         "type": {"key": "uuid", "keyRefTable": "Port", "min": 0, "max": 1}},
       "output_vlan": {
         "comment": "Output VLAN for selected packets.  Mutually exclusive with output_port.",
         "type": {"key": "integer", "min": 0, "max": 1}}}},
   "NetFlow": {
     "comment": "A NetFlow target.",
     "columns": {
       "targets": {
         "comment": "NetFlow targets in the form \"IP:PORT\".",
         "type": {"key": "string", "min": 1, "max": "unlimited"}},
       "engine_type": {
         "comment": "Engine type to use in NetFlow messages.  Defaults to datapath index if not specified.",
         "type": "integer", "min":0, "max":1},
       "engine_id": {
         "comment": "Engine ID to use in NetFlow messages.  Defaults to datapath index if not specified.",
         "type": "integer", "min":0, "max":1},
       "add_id_to_interface": {
         "comment": "Place least-significant 7 bits of engine ID into most significant bits of ingress and egress interface fields of NetFlow records?",
         "type": "boolean"},
       "active_timeout": {
         "comment": "Active timeout interval, in seconds.  A value of 0 requests the default timeout; a negative value disables active timeouts.",
         "type": "integer"}}},
   "Controller": {
     "comment": "An OpenFlow controller.",
     "columns": {
       "target": {
         "comment": "Connection method for controller, e.g. \"ssl:...\", \"tcp:...\".  The special string \"discover\" enables controller discovery.  The special string \"none\" disables the controller.",
         "type": "string"},
       "max_backoff": {
         "comment": "Maximum number of milliseconds to wait between connection attempts.  Default is implementation-specific.",
         "type": {"key": "integer", "min": 0, "max": 1}},
       "inactivity_probe": {
         "comment": "Maximum number of milliseconds of idle time on connection to controller before sending an inactivity probe message.  Default is implementation-specific.",
         "type": {"key": "integer", "min": 0, "max": 1}},
       "fail_mode": {
         "comment": "Either \"standalone\" or \"secure\", or empty to use the implementation's default.",
         "type": {"key": "string", "min": 0, "max": 1}},
       "discover_accept_regex": {
         "comment": "If \"target\" is \"discover\", a POSIX extended regular expression against which the discovered controller location is validated.  If not specified, the default is implementation-specific.",
         "type": {"key": "string", "min": 0, "max": 1}},
       "discover_update_resolv_conf": {
         "comment": "If \"target\" is \"discover\", whether to update /etc/resolv.conf when the controller is discovered.  If not specified, the default is implementation-specific.",
         "type": {"key": "boolean", "min": 0, "max": 1}},
       "connection_mode": {
         "comment": "Either \"in-band\" or \"out-of-band\".  If not specified, the default is implementation-specific.",
         "type": {"key": "string", "min": 0, "max": 1}},
       "local_ip": {
         "comment": "If \"target\" is not \"discover\", the IP address to configure on the local port.",
         "type": {"key": "string", "min": 0, "max": 1}},
       "local_netmask": {
         "comment": "If \"target\" is not \"discover\", the IP netmask to configure on the local port.",
         "type": {"key": "string", "min": 0, "max": 1}},
       "local_gateway": {
         "comment": "If \"target\" is not \"discover\", the IP gateway to configure on the local port.",
         "type": {"key": "string", "min": 0, "max": 1}},
       "controller_rate_limit": {
         "comment": "The maximum rate at which packets will be forwarded to the OpenFlow controller, in packets per second.  If not specified, the default is implementation-specific.",
         "type": {"key": "integer", "min": 0, "max": 1}},
       "controller_burst_limit": {
         "comment": "The maximum number of unused packet credits that the bridge will allow to accumulate, in packets.  If not specified, the default is implementation-specific.",
         "type": {"key": "integer", "min": 0, "max": 1}}}},
   "SSL": {
     "comment": "SSL configuration for an Open_vSwitch.",
     "columns": {
       "private_key": {
         "comment": "Name of a PEM file containing the private key used as the switch's identity for SSL connections to the controller.",
         "type": "string"},
       "certificate": {
         "comment": "Name of a PEM file containing a certificate, signed by the certificate authority (CA) used by the controller and manager, that certifies the switch's private key, identifying a trustworthy switch.",
         "type": "string"},
       "ca_cert": {
         "comment": "Name of a PEM file containing the CA certificate used to verify that the switch is connected to a trustworthy controller.",
         "type": "string"},
       "bootstrap_ca_cert": {
         "comment": "If set to true, then Open vSwitch will attempt to obtain the CA certificate from the controller on its first SSL connection and save it to the named PEM file. If it is successful, it will immediately drop the connection and reconnect, and from then on all SSL connections must be authenticated by a certificate signed by the CA certificate thus obtained.  This option exposes the SSL connection to a man-in-the-middle attack obtaining the initial CA certificate, but it may be useful for bootstrapping.",
         "type": "boolean"}}}}}
